# ============================================
# Backfill All Historical Releases
# Republishes ALL releases from cedya77/aiometadata
# Uses native ARM64 runners to avoid QEMU issues
# Run manually via workflow_dispatch
# ============================================

name: Backfill Historical Releases

on:
  workflow_dispatch:
    inputs:
      start_from_version:
        description: 'Start from specific version (leave empty for all)'
        required: false
        default: ''
      dry_run:
        description: 'Dry run (no push)'
        required: false
        default: false
        type: boolean
      skip_existing:
        description: 'Skip versions that already exist on ghcr.io'
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: jigsawfr/aiometadata-docker
  SOURCE_REPO: cedya77/aiometadata

permissions:
  contents: write
  packages: write
  id-token: write  # For cosign OIDC

jobs:
  # ============================================
  # Job 1: Fetch all releases from source repo
  # ============================================
  fetch-releases:
    name: Fetch All Releases
    runs-on: ubuntu-latest
    outputs:
      releases: ${{ steps.get-releases.outputs.releases }}
      count: ${{ steps.get-releases.outputs.count }}
    steps:
      - name: Fetch releases from source repository
        id: get-releases
        uses: actions/github-script@v7
        with:
          script: |
            const allReleases = [];
            let page = 1;
            
            // Fetch all releases with pagination
            while (true) {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: 'cedya77',
                repo: 'aiometadata',
                per_page: 100,
                page: page
              });
              
              if (releases.length === 0) break;
              allReleases.push(...releases);
              page++;
            }
            
            // Sort chronologically (oldest first)
            allReleases.sort((a, b) => new Date(a.published_at) - new Date(b.published_at));
            
            // Filter based on start_from_version if provided
            const startFrom = '${{ inputs.start_from_version }}';
            let filteredReleases = allReleases;
            
            if (startFrom) {
              const startIndex = allReleases.findIndex(r => r.tag_name === `v${startFrom}` || r.tag_name === startFrom);
              if (startIndex !== -1) {
                filteredReleases = allReleases.slice(startIndex);
              }
            }
            
            // Map to simplified format
            const releaseData = filteredReleases.map(r => ({
              tag: r.tag_name.replace(/^v/, ''),
              tag_full: r.tag_name,
              prerelease: r.prerelease,
              published_at: r.published_at,
              body: r.body || '',
              sha: r.target_commitish
            }));
            
            console.log(`Found ${releaseData.length} releases to process`);
            releaseData.forEach(r => console.log(`  - ${r.tag_full} (${r.prerelease ? 'prerelease' : 'stable'})`));
            
            core.setOutput('releases', JSON.stringify(releaseData));
            core.setOutput('count', releaseData.length);

  # ============================================
  # Job 2: Build per-arch images (native runners)
  # ============================================
  build-arch:
    name: Build ${{ matrix.release.tag_full }} (${{ matrix.arch }})
    needs: fetch-releases
    if: needs.fetch-releases.outputs.count > 0
    runs-on: ${{ matrix.arch == 'arm64' && 'ubuntu-24.04-arm' || 'ubuntu-latest' }}
    strategy:
      fail-fast: false
      max-parallel: 2  # One per arch at a time
      matrix:
        release: ${{ fromJson(needs.fetch-releases.outputs.releases) }}
        arch: [amd64, arm64]
    outputs:
      # We need to pass digest info to the merge job
      built: ${{ steps.build.outputs.digest != '' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Check if image already exists (only on amd64 to avoid duplicate checks)
      - name: Check if image exists
        id: check-exists
        if: inputs.skip_existing && matrix.arch == 'amd64'
        run: |
          VERSION="${{ matrix.release.tag }}"
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION} > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "â­ï¸ Image ${VERSION} already exists, skipping..."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Image ${VERSION} not found, will build..."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check skip status
        id: should-skip
        run: |
          if [[ "${{ inputs.skip_existing }}" == "true" && "${{ steps.check-exists.outputs.exists }}" == "true" ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      # Setup Docker Buildx
      - name: Set up Docker Buildx
        if: steps.should-skip.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        if: steps.should-skip.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build and push arch-specific image
      - name: Build and Push ${{ matrix.arch }} image
        if: steps.should-skip.outputs.skip != 'true'
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/${{ matrix.arch }}
          push: ${{ inputs.dry_run != true }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.release.tag }}-${{ matrix.arch }}
          build-args: |
            VERSION=${{ matrix.release.tag }}
            BUILD_DATE=${{ matrix.release.published_at }}
            VCS_REF=${{ matrix.release.sha }}
          cache-from: type=gha,scope=${{ matrix.release.tag }}-${{ matrix.arch }}
          cache-to: type=gha,scope=${{ matrix.release.tag }}-${{ matrix.arch }},mode=max
          provenance: false
          sbom: false
          outputs: type=image,compression=zstd

  # ============================================
  # Job 3: Create multi-arch manifest & sign
  # ============================================
  create-manifest:
    name: Manifest ${{ matrix.release.tag_full }}
    needs: [fetch-releases, build-arch]
    if: needs.fetch-releases.outputs.count > 0 && inputs.dry_run != true
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        release: ${{ fromJson(needs.fetch-releases.outputs.releases) }}
    
    steps:
      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Check if we should skip
      - name: Check if image exists
        id: check-exists
        if: inputs.skip_existing
        run: |
          VERSION="${{ matrix.release.tag }}"
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION} > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Check skip status
        id: should-skip
        run: |
          if [[ "${{ inputs.skip_existing }}" == "true" && "${{ steps.check-exists.outputs.exists }}" == "true" ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      # Extract version components
      - name: Extract version components
        if: steps.should-skip.outputs.skip != 'true'
        id: version
        run: |
          VERSION="${{ matrix.release.tag }}"
          BASE_VERSION=$(echo "$VERSION" | cut -d'-' -f1)
          MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
          MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "major_minor=${MAJOR}.${MINOR}" >> $GITHUB_OUTPUT
          IS_BETA="${{ matrix.release.prerelease }}"
          if [[ "$VERSION" == *"beta"* ]]; then IS_BETA="true"; fi
          echo "is_beta=$IS_BETA" >> $GITHUB_OUTPUT

      # Create and push multi-arch manifest
      - name: Create multi-arch manifest
        if: steps.should-skip.outputs.skip != 'true'
        run: |
          VERSION="${{ matrix.release.tag }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          
          echo "ðŸ“¦ Creating manifest for ${VERSION}..."
          
          # Create manifest with both architectures
          docker manifest create ${IMAGE}:${VERSION} \
            ${IMAGE}:${VERSION}-amd64 \
            ${IMAGE}:${VERSION}-arm64
          
          # Push version tag
          docker manifest push ${IMAGE}:${VERSION}
          echo "âœ… Pushed ${IMAGE}:${VERSION}"
          
          # Additional tags for stable releases
          if [[ "${{ steps.version.outputs.is_beta }}" != "true" ]]; then
            # Major.minor tag
            docker manifest create ${IMAGE}:${{ steps.version.outputs.major_minor }} \
              ${IMAGE}:${VERSION}-amd64 \
              ${IMAGE}:${VERSION}-arm64
            docker manifest push ${IMAGE}:${{ steps.version.outputs.major_minor }}
            echo "âœ… Pushed ${IMAGE}:${{ steps.version.outputs.major_minor }}"
            
            # Major tag
            docker manifest create ${IMAGE}:${{ steps.version.outputs.major }} \
              ${IMAGE}:${VERSION}-amd64 \
              ${IMAGE}:${VERSION}-arm64
            docker manifest push ${IMAGE}:${{ steps.version.outputs.major }}
            echo "âœ… Pushed ${IMAGE}:${{ steps.version.outputs.major }}"
            
            # Latest tag
            docker manifest create ${IMAGE}:latest \
              ${IMAGE}:${VERSION}-amd64 \
              ${IMAGE}:${VERSION}-arm64
            docker manifest push ${IMAGE}:latest
            echo "âœ… Pushed ${IMAGE}:latest"
          else
            # Beta tag
            docker manifest create ${IMAGE}:beta \
              ${IMAGE}:${VERSION}-amd64 \
              ${IMAGE}:${VERSION}-arm64
            docker manifest push ${IMAGE}:beta
            echo "âœ… Pushed ${IMAGE}:beta"
          fi

      # Install Cosign for signing
      - name: Install Cosign
        if: steps.should-skip.outputs.skip != 'true'
        uses: sigstore/cosign-installer@v3

      # Sign the manifest
      - name: Sign manifest with Cosign
        if: steps.should-skip.outputs.skip != 'true'
        run: |
          VERSION="${{ matrix.release.tag }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          
          # Get the manifest digest
          DIGEST=$(docker manifest inspect ${IMAGE}:${VERSION} -v | jq -r '.Descriptor.digest')
          
          echo "ðŸ” Signing ${IMAGE}@${DIGEST}..."
          cosign sign --yes ${IMAGE}@${DIGEST}
          echo "âœ… Signed successfully"

      # Cleanup arch-specific tags (optional, keeps registry clean)
      - name: Cleanup arch-specific tags
        if: steps.should-skip.outputs.skip != 'true'
        continue-on-error: true
        run: |
          echo "ðŸ§¹ Arch-specific tags (${VERSION}-amd64, ${VERSION}-arm64) kept for manifest reference"

  # ============================================
  # Job 4: Summary
  # ============================================
  summary:
    name: Build Summary
    needs: [fetch-releases, build-arch, create-manifest]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "## ðŸ“¦ Backfill Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Total releases processed**: ${{ needs.fetch-releases.outputs.count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Architectures**: amd64, arm64 (native runners)" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry run**: ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Skip existing**: ${{ inputs.skip_existing }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All historical releases have been processed!" >> $GITHUB_STEP_SUMMARY
